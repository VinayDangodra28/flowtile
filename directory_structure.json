{
    "App.jsx": "import React from \"react\";\nimport Editor from \"./components/Editor/Editor\";\n\nconst App = () => {\n  return (\n    <div>\n      <h1>FlowTile: Canvas Shape Manager</h1>\n      <Editor />\n    </div>\n  );\n};\n\nexport default App;\n",
    "assets": {},
    "components": {
        "Editor": {
            "Editor.jsx": "import React, { useRef, useState, useEffect } from \"react\";\nimport Shape from \"./Shape\";\nimport \"./styles.css\";\n\nconst Editor = () => {\n  const canvasRef = useRef(null);\n  const [canvasSize, setCanvasSize] = useState({ width: 500, height: 500 });\n  const [shapes, setShapes] = useState([]);\n  const [selectedShape, setSelectedShape] = useState(null);\n  const [dragging, setDragging] = useState(false);\n  const [resizing, setResizing] = useState(false);\n  const [gridImage, setGridImage] = useState(null);\n  const [gridCols, setGridCols] = useState(10); // Default columns\n  const [gridRows, setGridRows] = useState(10); // Default rows\n  const [progress, setProgress] = useState(0); // Progress for grid generation\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    const draw = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      shapes.forEach((shape) => {\n        shape.updatePosition(canvas.width, canvas.height);\n        shape.draw(ctx, canvas.width, canvas.height, shape === selectedShape);\n      });\n      requestAnimationFrame(draw);\n    };\n\n    draw();\n  }, [shapes, selectedShape]);\n\n  const handleMouseDown = (e) => {\n    const rect = canvasRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if (selectedShape && selectedShape.isResizeHandleClicked(x, y)) {\n      setResizing(true);\n      return;\n    }\n\n    const clickedShape = shapes.find((shape) => shape.isClicked(x, y));\n    setSelectedShape(clickedShape);\n\n    if (clickedShape) {\n      setDragging(true);\n      clickedShape.offset = {\n        x: x - clickedShape.x, // Store offset\n        y: y - clickedShape.y,\n      };\n    }\n  };\n\n  const handleMouseMove = (e) => {\n    const rect = canvasRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if (dragging && selectedShape) {\n      selectedShape.x = x - selectedShape.offset.x;\n      selectedShape.y = y - selectedShape.offset.y;\n    }\n\n    if (resizing && selectedShape) {\n      const dx = x - selectedShape.x;\n      const dy = y - selectedShape.y;\n      selectedShape.size = Math.max(10, Math.sqrt(dx * dx + dy * dy));\n    }\n  };\n\n  const handleMouseUp = () => {\n    setDragging(false);\n    setResizing(false);\n    if (selectedShape) {\n      delete selectedShape.offset; // Clear offset after dragging\n    }\n  };\n\n  const addShape = (type) => {\n    const x = Math.random() * canvasSize.width;\n    const y = Math.random() * canvasSize.height;\n    const size = 20 + Math.random() * 30;\n    const color = `hsl(${Math.random() * 360}, 70%, 50%)`;\n    const newShape = new Shape(x, y, size, color, type);\n    setShapes([...shapes, newShape]);\n  };\n\n  const deleteShape = () => {\n    if (selectedShape) {\n      setShapes(shapes.filter((shape) => shape !== selectedShape));\n      setSelectedShape(null);\n    }\n  };\n\n  const downloadCanvas = () => {\n    const link = document.createElement(\"a\");\n    link.download = \"canvas.png\";\n    link.href = canvasRef.current.toDataURL();\n    link.click();\n  };\n\n  const updateCanvasSize = () => {\n    const width = parseInt(document.getElementById(\"canvasWidth\").value);\n    const height = parseInt(document.getElementById(\"canvasHeight\").value);\n    setCanvasSize({ width, height });\n  };\n\n  // Web Worker for grid generation\n  const generateGridImageWithWorker = () => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const canvasData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  \n    // Use the correct path to the worker file\n    const worker = new Worker(\"/gridWorker.js\"); // Path to your worker in the public folder\n  \n    worker.postMessage({\n      gridCols,\n      gridRows,\n      canvasData,\n      canvasWidth: canvas.width,\n      canvasHeight: canvas.height,\n    });\n  \n    worker.onmessage = function (e) {\n      const { imageUrl } = e.data;\n      setGridImage(URL.createObjectURL(imageUrl)); // Show the generated grid\n    };\n  };\n  \n\n  const showGrid = () => {\n    return gridImage ? (\n      <div style={{ display: \"flex\", justifyContent: \"center\", marginTop: \"20px\" }}>\n        <img\n          src={gridImage}\n          alt=\"Generated Grid\"\n          style={{\n            objectFit: \"contain\",\n            maxWidth: \"100%\",\n            maxHeight: \"400px\", // Fixed height for the grid\n          }}\n        />\n      </div>\n    ) : (\n      <p>No grid generated yet.</p>\n    );\n  };\n\n  return (\n    <div>\n      <h2>Shape Editor</h2>\n      <div style={{ display: \"flex\", marginBottom: \"20px\" }}>\n        {/* Left Panel: Shape Tools */}\n        <div style={{ marginRight: \"20px\" }}>\n          <h3>Shapes</h3>\n          <button onClick={() => addShape(\"circle\")}>Add Circle</button>\n          <button onClick={() => addShape(\"square\")}>Add Square</button>\n          <button onClick={deleteShape}>Delete Selected</button>\n        </div>\n\n        {/* Center Panel: Canvas */}\n        <div>\n          <div>\n            <label htmlFor=\"canvasWidth\">Width:</label>\n            <input id=\"canvasWidth\" type=\"number\" defaultValue={canvasSize.width} />\n            <label htmlFor=\"canvasHeight\">Height:</label>\n            <input id=\"canvasHeight\" type=\"number\" defaultValue={canvasSize.height} />\n            <button onClick={updateCanvasSize}>Update Canvas Size</button>\n            <button onClick={downloadCanvas}>Download Canvas</button>\n          </div>\n          <canvas\n            ref={canvasRef}\n            width={canvasSize.width}\n            height={canvasSize.height}\n            style={{ border: \"1px solid black\" }}\n            onMouseDown={handleMouseDown}\n            onMouseMove={handleMouseMove}\n            onMouseUp={handleMouseUp}\n          ></canvas>\n        </div>\n\n        {/* Right Panel: Shape Editor */}\n        <div style={{ marginLeft: \"20px\" }}>\n          <h3>Shape Editor</h3>\n          {selectedShape ? (\n            <>\n              <label>\n                Color:\n                <input\n                  type=\"color\"\n                  value={selectedShape.color}\n                  onChange={(e) => {\n                    selectedShape.color = e.target.value;\n                  }}\n                />\n              </label>\n              <br />\n              <label>\n                Size:\n                <input\n                  type=\"number\"\n                  value={selectedShape.size}\n                  onChange={(e) => {\n                    selectedShape.size = Math.max(10, parseInt(e.target.value));\n                  }}\n                />\n              </label>\n            </>\n          ) : (\n            <p>Select a shape to edit</p>\n          )}\n        </div>\n      </div>\n\n      {/* Grid Generation Inputs */}\n      <div>\n        <label htmlFor=\"gridCols\">Grid Columns:</label>\n        <input\n          id=\"gridCols\"\n          type=\"number\"\n          value={gridCols}\n          onChange={(e) => setGridCols(Math.max(1, parseInt(e.target.value)))}\n        />\n        <br />\n        <label htmlFor=\"gridRows\">Grid Rows:</label>\n        <input\n          id=\"gridRows\"\n          type=\"number\"\n          value={gridRows}\n          onChange={(e) => setGridRows(Math.max(1, parseInt(e.target.value)))}\n        />\n        <br />\n        <button onClick={generateGridImageWithWorker}>Generate Grid</button>\n      </div>\n\n      {/* Show Grid Image */}\n      {showGrid()}\n    </div>\n  );\n};\n\nexport default Editor;\n",
            "GridGenerator.jsx": "",
            "Shape.jsx": "export default class Shape {\n  constructor(x, y, size, color, type = \"circle\") {\n    this.x = x;\n    this.y = y;\n    this.size = size;\n    this.color = color;\n    this.type = type; // \"circle\" or \"square\"\n  }\n\n  draw(ctx, canvasWidth, canvasHeight, isSelected) {\n    ctx.fillStyle = this.color;\n\n    if (this.type === \"circle\") {\n      // Draw circle\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n      ctx.fill();\n    } else if (this.type === \"square\") {\n      // Draw square\n      ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);\n    }\n\n    // Draw border and resize handle if selected\n    if (isSelected) {\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 2;\n\n      if (this.type === \"circle\") {\n        // Circle border\n        ctx.strokeRect(\n          this.x - this.size,\n          this.y - this.size,\n          this.size * 2,\n          this.size * 2\n        );\n      } else if (this.type === \"square\") {\n        // Square border\n        ctx.strokeRect(\n          this.x - this.size,\n          this.y - this.size,\n          this.size * 2,\n          this.size * 2\n        );\n      }\n\n      // Draw resize handle\n      const handleSize = 10;\n      ctx.fillStyle = \"gray\";\n      ctx.fillRect(\n        this.x + this.size - handleSize / 2,\n        this.y + this.size - handleSize / 2,\n        handleSize,\n        handleSize\n      );\n    }\n\n    this.wrapAround(ctx, canvasWidth, canvasHeight);\n  }\n\n  isClicked(mx, my) {\n    if (this.type === \"circle\") {\n      return Math.hypot(mx - this.x, my - this.y) <= this.size;\n    } else if (this.type === \"square\") {\n      return (\n        mx >= this.x - this.size &&\n        mx <= this.x + this.size &&\n        my >= this.y - this.size &&\n        my <= this.y + this.size\n      );\n    }\n    return false;\n  }\n\n  isResizeHandleClicked(mx, my) {\n    const handleSize = 10;\n    const handleX = this.x + this.size - handleSize / 2;\n    const handleY = this.y + this.size - handleSize / 2;\n    return (\n      mx >= handleX &&\n      mx <= handleX + handleSize &&\n      my >= handleY &&\n      my <= handleY + handleSize\n    );\n  }\n\n  wrapAround(ctx, canvasWidth, canvasHeight) {\n    const offsets = [\n      { dx: 0, dy: 0 }, // Original position\n      { dx: -canvasWidth, dy: 0 }, // Left\n      { dx: canvasWidth, dy: 0 }, // Right\n      { dx: 0, dy: -canvasHeight }, // Top\n      { dx: 0, dy: canvasHeight }, // Bottom\n      { dx: -canvasWidth, dy: -canvasHeight }, // Top-left corner\n      { dx: canvasWidth, dy: -canvasHeight }, // Top-right corner\n      { dx: -canvasWidth, dy: canvasHeight }, // Bottom-left corner\n      { dx: canvasWidth, dy: canvasHeight }, // Bottom-right corner\n    ];\n\n    offsets.forEach(({ dx, dy }) => {\n      if (this.type === \"circle\") {\n        ctx.beginPath();\n        ctx.arc(this.x + dx, this.y + dy, this.size, 0, Math.PI * 2);\n        ctx.fill();\n      } else if (this.type === \"square\") {\n        ctx.fillRect(\n          this.x + dx - this.size,\n          this.y + dy - this.size,\n          this.size * 2,\n          this.size * 2\n        );\n      }\n    });\n  }\n\n  updatePosition(canvasWidth, canvasHeight) {\n    if (this.x < 0) {\n      this.x += canvasWidth;\n    } else if (this.x > canvasWidth) {\n      this.x -= canvasWidth;\n    }\n\n    if (this.y < 0) {\n      this.y += canvasHeight;\n    } else if (this.y > canvasHeight) {\n      this.y -= canvasHeight;\n    }\n  }\n}\n",
            "styles.css": "canvas {\n    display: block;\n    margin: auto;\n  }\n  "
        },
        "UIControls.jsx": "import React from \"react\";\n\nconst UIControls = ({ addShape, deleteShape, downloadCanvas, updateCanvasSize }) => (\n  <div>\n    <button onClick={addShape}>Add Shape</button>\n    <button onClick={deleteShape}>Delete Selected</button>\n    <button onClick={downloadCanvas}>Download Canvas</button>\n  </div>\n);\n\nexport default UIControls;\n"
    },
    "hooks": {
        "useCanvas,jsx": "import { useRef, useEffect } from \"react\";\n\nconst useCanvas = (draw) => {\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    let animationFrameId;\n\n    const render = () => {\n      draw(ctx);\n      animationFrameId = requestAnimationFrame(render);\n    };\n\n    render();\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [draw]);\n\n  return canvasRef;\n};\n\nexport default useCanvas;\n"
    },
    "index.css": "",
    "main.jsx": "import { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport './index.css'\nimport App from './App.jsx'\n\ncreateRoot(document.getElementById('root')).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n)\n",
    "utils": {
        "shapeUtils.jsx": "export const generateRandomColor = () => {\n    return `hsl(${Math.random() * 360}, 70%, 50%)`;\n  };\n  \n  export const generateRandomPosition = (canvasWidth, canvasHeight) => {\n    return {\n      x: Math.random() * canvasWidth,\n      y: Math.random() * canvasHeight,\n    };\n  };\n  \n  export const isPointInsideCircle = (x, y, circleX, circleY, radius) => {\n    return Math.hypot(x - circleX, y - circleY) <= radius;\n  };\n  "
    }
}